Inherited Polymorphism High
====
##
### [返回JavaSE目录](./JavaSEDirectory.md) [回到首页目录](/README.md)

	第一节 抽象类
	第二节 接  口
	第三节 内部类   
	第四节 枚  举 
	第五节 注  解 



## 抽象类

### 模板设计模式

	模板类= 具体功能（普通方法）+模板功能（抽象方法）
	
	抽象类设计成模板类
	子类继承抽象类，可以应用模板


## 接口

### 接口的概念

	里面都是抽象方法的“抽象类”，称为接口
	
	案例：
	
	接口————张三丰
	抽象类——张翠山、宋远桥
	具体实现类——张无忌、宋青书
	
	演员：
	不出名：什么角色都能演，都去演——————————————————具体实现类
	出名：什么角色都能演，选择性的只演比较好的角色————抽象类
	导演、开了工作室：什么角色都能演，不用自己去演，而是教下属怎么去演————接口
	
	
	接口 层级结构比较靠上


### 接口的好处

	1、避免了java中单继承的局限性 ★
	2、接口的实现更加灵活，类和接口之间不用是is-a 的关系，只要是 like-a的关系即可
	3、接口的使用降低了耦合性（降低了类和类的依赖性）

### 接口的定义特点

	  1.接口使用interface定义
	  2.接口中不能有普通的属性和普通的方法
	  3.里面全是全局常量和抽象方法，
	  	全局常量的修饰符只能是 public static final,可以省略
	   抽象方法的修饰符只能是 public abstract，可以省略
	  4.接口中没有构造器
	  5.接口不能实例化
	  6.接口的修饰符只能是默认或public，不能是final或其他访问修饰符

### 接口的扩展特点

	  1.类实现接口，需要关键字implements
	  2.普通实现类实现接口，必须实现里面所有的抽象方法
	    抽象类实现接口，可以不用实现里面所有的抽象方法
	  3.一个类可以实现多个接口，接口间用逗号隔开
	  语法：
	  class A implements 接口1，接口2{
	 
	  }
	  4.一个类可以既继承，又实现接口
	  语法：
	  class A extends 类B implements  接口1，接口2{
	  	
	  }
	  
	  5.接口可以继承其他接口，而且支持多继承
	  语法：
	  interface A extends 接口1，接口2{
	  }
	  
	  总结：
	  ①接口支持多继承，多实现
	  ②接口和接口之间的关系 ，称为继承
	   类和类之间的关系，称为继承
	   类和接口之间的关系，称为实现
	   
	  ③ 继承用到关键字：extends
	    实现用到关键字：implements



### 接口的应用

	接口和实现类之间应用在多态上
	
	
	接口A a = new 实现类();//向上转型
	实现类 b =(实现类)a;//向下转型
	
	多态数组
	
	多态参数


### 接口的应用体会

	接口的设计可以认为体现了 规范的意义
	抽象类的设计 可以认为体现了模板的意义 
	
	接口 ：一组规范的集合
	
	
	一流企业卖标准，二流企业卖设计，三流企业卖产品


### 接口和抽象类的对比

			关键字			能否实例化		有无构造器	里面可以有谁					抽象方法的修饰符					是否是单继承
	
	抽象类	abstract		不可以			有			可以有普通成员和抽象方法		不能是private、static、			是																			fianl，其他可以
	
	接口		interface		不可以			无			只能是全局常量和抽象方法		只能是public abstract			不是

```java
	interface A{
		void method();

	}
	class B implements A{
		public void method(){

		}

	}
```

## 内部类

### 内部类的概念

	一个类中又可以完整的定义另外一个类。
	在里面的类称为内部类
	里面嵌套别的类的类称为外部类
	
	
	class A{//外部类
		class B{//内部类
	
		}
	
	}
	class C{//外部其他类
	
	}

### 内部类的好处

	1.可以直接访问外部类的所有成员，甚至包含私有
	2.在一定程度上实现了多继承

### 内部类的分类

	按定义位置不同，分为两大类：

	定义在成员位置上：
		成员内部类（没有使用static修饰）
		静态内部类（使用static修饰）

	定义在局部位置上：
		局部内部类（有类名）
		匿名内部类（没有类名）

### 成员内部类的特点

	  1.内部类定义在类体中 
	  2.内部类中可以有属性、方法、构造、初始化块、类 
	  3.内部类可以加任意访问修饰符
	  4.互访原则
	  内部类如何访问外部类的成员? ★ 直接访问！！！！
	  
	  外部类如何访问内部类的成员？ 需要通过创建内部类对象，然后再调用，语法： 内部类 对象名 = new 内部类(); 对象名.方法();
	  
	  外部其他类如何访问内部类的成员？ 需要通过创建内部类对象，然后再调用，语法： 外部类.内部类 对象名 = new 外部类().new 内部类();
	  对象名.方法();


### 静态内部类的特点

	 1.静态内部类定义在成员位置，加上修饰符static
	 2.静态内部类可以有属性、方法、构造、初始化块、内部类,也可以有静态成员！！！！
	 3.可以加任意修饰符
     4.互访原则
	  		1) 内部类如何访问外部类？
	  			只能直接访问外部类的静态成员，包含私有的！！！
	  		2) 外部类如何访问内部类？
	  			需要通过创建内部类对象，然后再调用，
	  			语法： 内部类 对象名 = new 内部类(); 对象名.方法();
	  		3) 外部其他类如何访问内部类？
	  			需要通过创建内部类对象，然后再调用
	  			语法：Outer2.Inner2 i =new Outer2.Inner2();
	  			
	  
	  5.当内部类和外部类出现重名成员时，遵循就近原则，默认访问的是内部类的成员，如果需要访问外部类的成员，需要通过外部类名.成员 方式调用

### 局部内部类的特点

	  1.修饰符:
	 		不能加任何访问修饰符
	  2.类体中的成员都有哪些？
	  		五大成员都可以,但不允许定义静态成员！！！（和加载顺序有关）
	  		
	  3.作用域
	  		作用范围较小，仅仅在定义它的方法或代码块中，而且遵循前向引用（必须先定义再使用）
	  4.重名问题
	  		当外部类的成员和内部类的成员出现重名问题时，遵循就近原则，如果想访问外部类的成员，需要通过：外部类名.this.成员  方式访问
	  		
	  5.互访原则
	  		1） 内访外
	  			可以直接访问外部类的所有成员，但局部变量不一定能访问
	  			① 其他作用范围下的局部变量，肯定不能访问
	  			② 内部类只能直接访问同一个作用范围下的final修饰的局部变量
	  			原因：
	  			局部内部类的生命周期>局部变量的生命周期
	  			如果局部内部类能直接访问局部变量，就会导致 局部内部类在引用一个已经不存在的变量
	 			1、将局部变量拷贝了一个备份，让局部内部类引用，但可能导致数据不一致的尴尬
	  			2、将局部变量加上final修饰符，这样局部内部类中将不可以更新备份
	  
	  		2）外访内
	  			只能在定义该局部内部类的代码块中访问该局部内部类，而且遵循前向引用
	  			通过创建对象即可

### 匿名内部类的特点

	   1.语法：
	  	new 父类或接口(){};
	   2.修饰符
	   	不能有访问修饰符
	   3.类体的成员都有哪些
	   	除了构造，其他都可以
	   	
	   4.重名的问题
	  		 当外部类的成员和内部类的成员出现重名问题时，遵循就近原则，如果想访问外部类的成员，需要通过：外部类名.this.成员  方式访问
	  	5.作用域问题
	  		作用范围仅仅在定义它的方法或代码块中，使用时遵循前向引用
	  		语法：
	  		1)new 父类或接口(){}.方法();
	  		2)父类或接口 a =new 父类或接口(){};
	  		  a.方法();
	   6.互访原则	
	   	1）内访外
	   		
	  			可以直接访问外部类的所有成员，但局部变量不一定能访问
	  			① 其他作用范围下的局部变量，肯定不能访问
	  			② 内部类只能直接访问同一个作用范围下的final修饰的局部变量
	  			原因：
	  			局部内部类的生命周期>局部变量的生命周期
	  			如果局部内部类能直接访问局部变量，就会导致 局部内部类在引用一个已经不存在的变量
	  			1、将局部变量拷贝了一个备份，让局部内部类引用，但可能导致数据不一致的尴尬
	  			2、将局部变量加上final修饰符，这样局部内部类中将不可以更新备份
	  
	  		2）外访内
	  			只能在定义该局部内部类的代码块中访问该局部内部类，而且遵循前向引用
	  			语法同 第五点
	  			
	   7、应用场合
	   	一般用在参数传递上
	

	
## 枚举

### 枚举的概念

	一个类的对象 只是一组有限的值
	示例：
	
	季节类：春夏秋冬
	性别类：男、女、中、不男不女
	星期类：一——日
	
	
	单例模式：
	一个类中只有一个对象


### 如何自定义枚举 

	1、构造器私有化
 	2、本类创建对象（一组），修饰符为public static final 

示例：

	//有参构造

	class Season{
		private String name;//季节名
		private String description;//季节描述
		//②本类创建一组对象
		public static final Season SPRING=new Season("春天","万物复苏");
		public static final Season SUMMER=new Season("夏天","烈日炎炎");
		public static final Season AUTUMN=new Season("秋天","秋高气爽");
		public static final Season WINTER=new Season("冬天","白雪皑皑");
		//①构造器私有化
		private Season(String name, String description) {
			this.name = name;
			this.description = description;
		}
		public String getName() {
			return name;
		}
		public String getDescription() {
			return description;
		}
	}

### 使用enum关键字定义枚举 ★

	jdk5.0出现的新特性。
	  1.语法
	  enum 类名{
	  		对象(参数列表)，对象(参数列表);
	  		private 类名(参数列表){
	  		}
	  		....
	  }
	  ① 对象必须放在第一行
	  ② 对象默认修饰符就是 public static final 
	  ③如果是无参构造器，则构造器、对象后的括号都可以省略
	  ④ 枚举类中依然可以定义其他的方法
	  ⑤ 使用enum关键字定义的枚举类默认继承了 Enum类,所以具备该类中所有的方法


示例：

	enum Season2{
		//②本类创建一组对象
		 SPRING ("春天","万物复苏"),
		 SUMMER ("夏天","烈日炎炎"),
		 AUTUMN ("秋天","秋高气爽"),
		 WINTER ("冬天","白雪皑皑");
		
		private String name;//季节名
		private String description;//季节描述
		//①构造器私有化
		private Season2(String name, String description) {
			this.name = name;
			this.description = description;
		}
		public String getName() {
			return name;
		}
		public String getDescription() {
			return description;
		}
	}

### 枚举的常见方法 √

	  1.toString ：重写了Object类的toString方法，返回的是对象名字面值
	  2.name:返回的是对象名字面值 【用的较少】
	  3.valueOf:将字符串转换成枚举类的对象
	  4.values:返回当前枚举类中所有对象
	  5.ordinal：返回该枚举对象的次序号，从0开始
	  6.compareTo：比较两个枚举对象的大小，按次序号比较

### 枚举如何实现接口 ★


## 注解

### 注解的概念

	jdk5.0之后出现了注解的概念

	注解又称为 元数据，代表了对数据加以描述的文字
	注解 可以用于修饰：类、方法、属性、构造、包、局部变量
注解的好处：

	和注释类似，对数据加以解释说明，但和注释不一样的是，可以被编译、被运行，赋予了其他的意义


### jdk的内置注解★
	
	@Override :检验是否为有效的方法重写,仅仅可以修饰方法
	@SuppressWarnings:抑制编译警告，可以修饰类、属性、方法、构造、局部变量、参数
	@Deprecated:标记某个方法或某个类已经过时，提醒使用者可以选择其他方式，可以修饰任何数据

### 自定义注解

一、定义的语法

	@interface 注解名{

		类型 方法名() [default 值];
	}
	注意：
	1、类型 只能是 八大基本数据类型、String、枚举、Class以及上述类型 的数组
	2、方法名建议使用value，因为使用时可以省略
	3、 [default 值] 可选

二、使用的语法

	在被修饰的数据上方，添加：
	@注解名(方法名=值)

### 元注解

	1、Rentation：用于说明被修饰的注解 可以保留在什么期间
		SOURCE:源码期
		CLASS:编译期
		RUNTIME:运行时

	2、Target：用于说明被修饰的注解 可以修饰哪些数据
		 
		    TYPE,类
		
		    /** Field declaration (includes enum constants) */
		    FIELD,属性
		
		    /** Method declaration */
		    METHOD,方法
		
		    /** Parameter declaration */
		    PARAMETER,参数
		
		    /** Constructor declaration */
		    CONSTRUCTOR,构造
		
		    /** Local variable declaration */
		    LOCAL_VARIABLE,局部变量
		
		    /** Annotation type declaration */
		    ANNOTATION_TYPE, 枚举类
		
		    /** Package declaration */
		    PACKAGE 包

	3、Documented：用于说明被修饰的注解是否在帮助文档显示
		必须和Rentation搭配使用

	4、Inherited：代表被修饰的注解是否具备继承性
			用的较少
		