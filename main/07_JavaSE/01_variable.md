Variable
====
##
### [返回JavaSE目录](./JavaSEDirectory.md) [回到首页目录](/README.md)

	1、变量			
	2、标识符		
	3、数据类型
	4、运算符
	5、位运算与进制转换【选学】

## 数据类型

### 数据类型的分类

	基本数据类型
	
			整数
				字节整型 ：byte
				短整型：short
				整型：int
				长整形：long

			浮点数
				单精度：float
				双精度：double

			字符型
				char

			布尔类型
				boolean
	
	
	
	引用数据类型
			使用class或interface关键字定义，比如String
			数组

**问题：各数据类型的变量在内存中占的空间大小是多少呢？？？**


### 整型

	计算机存储单位是字节
	1个字节占8位
	01010111
	00000000————11111111
	00000000 00000000 ————11111111 11111111


			空间的大小		表示的数的范围
	
	byte	1个字节			-128~127
	short   2个字节			-2^15~2^15-1	
	int		4个字节			-2^31——2^31-1
	long    8个字节		    -2^63——2^63-1	


注意：

	1、编译器默认的整型 是int
	2、long类型的数值，最好加上 l或L
	long l = 1000l;


###浮点型
			空间大小	

	float	4个字节
	double	8个字节


注意：

	1、浮点型和整型在内存中存储原理不一样
	浮点型：阶码位+符号位+尾数

	导致精度有可能丢失
	2、如果精度丢失可以通过以下方式解决
	① 效果上，可以通过格式化方法实现解决精度丢失问题
	System.out.printf();
	② 本质上，可以通过BigDecimal

	3、编译器默认的浮点型 是double
	4、float类型的数组，最好加上 f或F
	float f = 1.5f;


### 字符型
			空间大小

	char 	2个字节


	
注意：

	1、一个字符型在内存中实际以整型存储
	存储：char c = '男';
	原理： 先去unicode码表中找 ‘男’对应的整数，转换成二进制，再存储
	读取：System.out.println(c);
	原理：从unicode吗表中找 数值对应的字符，再打印

	2、java中char类型默认的字符集 是unicode

	3、案例：
		char c1 = '\u0001';//存储的是unicode码表对应的数值（16进制）
		char c2 =97;//存储的是97整数对应的二进制
		char c3='\n';
	
引申：

ASCII:

	a:97
	A:65
	0:48
	单字节编码系统，所表示的字符非常少

ISO8859-1:

	比ASCII码表所表示的字符要多，但不支持中文

GB2312：

	支持中文，不包含繁体字

GBK:

	GBK>GB2312，支持的汉字比较多，而且包含繁体字

unicode：

	基本支持世界上所有的字符
	缺点：固定长度的字符编码
	所有的字符都占2个字节

utf-8：属于unicode的实现

	基本支持世界上所的字符
	可变长度的字符编码
	1个英文字母占一个字节，1个汉字占三个字节

### 布尔类型

				空间大小		表示的数

	boolean 	1个字节		true|false

	示例：boolean flag =true;
	


## 数据类型的转换

### 分类：

	基本类型之间的转换

		自动类型转换
		强转类型转换


	基本类型和String之间的转换

### 基本类型之间的转换

boolean 类型不参与转换


byte ——>short——> int——> long——>float——> double 

char
	
一、自动类型转换

	规则：小 变 大

	注意：
	1、 表达式有一个自动提升原则，提升操作数的最大类型
	



二、强转类型转换

	规则：大 变 小
	注意：
	1、强转符号只针对最近的有效
	示例：int i = (int)(1.5*4+2.5*8+100);
		int i2 =(int)1.5*4+(int)*8;

	
注意：

	1、char类型 可以直接存储 int的常量，不能直接存储int的变量，需要强转
	char c = 100;√
	int i=100;
	char c2=i;×

	2、byte、short类型 底层也是用int来存储的，如果运算时会自动转换成int类型
		byte b=100; √
		short s = 999;√

		short s2=b;√
		byte b2=(byte)s;√

		short s3 =(b+s);//★ ×
		short s4 = (short)(b+s); √
	


### String类型和基本类型之间的转换

一、基本类型转换成String

	注意：任意基本类型都行
	语法：直接拼接一个空字符串即可
	示例：
	int i = 100;
	String s = i+"";

二、String类型转换成 基本类型

	语法：直接通过基本类型的包装类调用 parseXX（string）

	示例：

	String s ="1234";
	int i =Integer.parseInt(s);

## 运算符

### 运算符的分类

	1、算术运算符
		基本算术运算符：+ - * / %
		自增、自减运算符： ++ --
	2、比较运算符
		> < >= <= == !=
	3、逻辑运算符
		&& || ！
	4、赋值运算符
		基本赋值运算符:=
		复合赋值运算符：+= 、-= 、*= 、/=、%=
	
	5、条件运算符
		表达式1?表达式2 :表达式3

### 算术运算符

一、基本算术运算符

		/ :左右两边都是整型，结果取整，小数点后面都舍弃
		% :取余
				a%b = a-a/b*b

二、自增、自减运算符

	属于一元运算符，只有一个操作数
	语法： i++;++i;int j=i++;  int j=++i;
	
	1.可以充当独立的语句使用

	i++;等价于++i;等价于i=i+1;

	2.作为表达式使用

	int j = ++i;
	int j=i++;
	System.out.println(i++);
	System.out.println(++i);

	① ++在前面
	int j=++i;
	i先本身自增，再将最新的值赋值给j

	② ++在后面
	int j=i++;
	先将i本身的值赋值给j，然后i再偷摸自增

### 赋值运算符

一、基本赋值运算符

	=

	int i = 10;

	特点：
	1、运算顺序 从右往左
	2、赋值号右边可以为 变量、常量、表达式，只要最终结果类型和赋值号左边的变量类型一致即可
	赋值号左边只能是变量

	
	int i = a+9;
	int j = b;
	int x = 100;

	int b= 10;

	3、赋值，相当于 将右边的值 赋值给左边变量，赋值也相当于复制


	案例： 两个变量 10和99，通过转换，最终 两个变量的值交换



二、复合赋值运算符

	+= -= *= 等

	特点：

	1、int a=10;
		a+=9;等价于 a=a+9;
	2、运算顺序 从右往左
	3、赋值号右边可以为 变量、常量、表达式，只要最终结果类型和赋值号左边的变量类型一致即可
	赋值号左边只能是变量

	a+=(b+100);等价于  a=a+(b+100);

	4.使用复合赋值运算符比 传统 基本赋值效率要高一丢丢
	a+=9;效率高于 a=a+9;

	5.使用复合赋值，不用进行强转，也不报错！！！

	short s=10;
	s+=2;等价于 s=s+2;但编译器进行了优化，里面自动实现了强转转换
	


### 比较运算符

	> < >= <= == !=


	特点：

	1、比较运算符属于二元运算符，也就是两个操作数
	2、比较表达式的最终结果类型为boolean类型
	boolean x = a>b;
	

### 逻辑运算符

	&& || !

	特点：
	1.功能：连接多个条件的
	2.逻辑表达式的最终结果为boolean类型

			语法				特点

	&&		条件1&&条件2		两个条件同时为true，最终结果才为true，反之结果都为false

	||		条件1||条件2		两个条件只要有一个为true，最终结果就为true，反之结果为false

	！		!条件			条件为true，最终结果为false，反之为true

			名称				特点						区别
	&		逻辑与			两个条件同时为true，      不管条件1是否成立，条件2都要判断
							最终结果才为true，
							反之结果都为false

	&&		短路与			两个条件同时为true，		如果条件1不成立，条件2则不执行
							最终结果才为true，
							反之结果都为false

	|		逻辑或			两个条件只要有一个为true，
							最终结果就为true，
							反之结果为false			不管条件1是否	成立，条件2都要判断

	||		短路或			同上					     如果条件1成立，条件2不用执行


	案例：
	int i=10;int j=99;
	if(i<=10 |(++j)==100){

		System.out.println("哈哈");

	}else{

		System.out.println("呵呵");
	}
	System.out.println(j);//100
	


	
	
### 三元运算符

	表达式1?表达式2 :表达式3

	特点：
	1.执行效果： 先判断表达式1的值，如果为true，最终结果为表达式2的值，反之为表达式3的值

	int a=100;
	int b=8;
	int c = a>b?100:9;

	2、表达式1 的最终类型为boolean类型，所以表达式1可以用关系表达式或逻辑表达式或boolean变量充当

		表达式2和表达式3的最终类型必须一致

	
### 运算符的优先级

	()> 自增、自减>基本算术>关系>逻辑>三元>赋值


## 输入功能

步骤1：导包

	位置：在class的上面导入
	语法：
	
	import java.util.Scanner;或import java.util.*;

步骤2：创建Scanner的变量

	位置：在main方法中
	Scanner input  = new Scanner(System.in);


步骤3：调用输入功能

	String name = input.next();//输入字符串
	int age = input.nextInt();//输入整型
	double score = input.nextDouble();//输入浮点型
	char sex= input.next().charAt(0);//输入char型


注意：输入上面都搭配输出语句，提高用户的体验


## 进制
### 了解常见的进制

	二进制		0-1
	十进制		0-9
	八进制		0-7
	十六进制		0-9	A-F

### 进制转换
	


## 位运算
### 位和字节
	
	计算机的存储的计量单位是 字节和位
	
	1个字节=8位
	
	1K = 1024个字节

### 原码、反码、补码

	☆计算机存储和计算都是以二进制的补码形式
	☆进制转换 都是以原码基础转换的

	正数：三码合一
	负数：
		反码： 符号位不变，其他位按位取反
		补码：反码+1


### 位运算符

	特点：
	1. 都是以二进制的补码形式进行运算
	2.符号位参与运算

	>>   右移           右移指定位数，最高位为0空缺位补0，最高位为1空缺位补1
	<<   左移           左移指定位数，空缺位补0
	>>>  无符号右移      右移指定位数，空缺位补0
	&    与             按位取与，两个都为1，结果为1，反之为0
	|    或             按位取或，只要有一个为1，结果为1，反之为0
	^    异或           按位异或，相同为0，不同为1
	~    取反           按位取反

	注意：进行位运算时，最好将数值转换成32位的二进制

    2 可以最快的变成8
		   2<<2    2*2^2

[回到顶部](#readme)









